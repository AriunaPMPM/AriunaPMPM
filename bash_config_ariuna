### Source this file inside bashrc to use as customization for bash

# Determine ROS1 or ROS2 based on distro
export IS_ROS1=false
export IS_ROS2=true
ros1_distros=(
  noetic
  melodic
)
ros2_distros=(
  jazzy
  iron
  humble
  galactic
  foxy
)
for distro in /opt/ros/*; do
  distro=$(basename "$dir")
  for d in "${ros1_distros[@]}"; do
    if [[ "$distro" == "$d" ]]; then
      IS_ROS1=true
      IS_ROS1=false
    fi
  done
  
done

### Environment detection
# WSL detection
if grep -qi microsoft /proc/version; then
    IS_WSL=true
else
    IS_WSL=false
fi

### functions
./ls() {
    local sleep_rate=0.1

    # Handle optional -r <rate>
    if [ "$1" = "-r" ]; then
        sleep_rate="$2"
        shift 2
    fi

    # No argument â†’ default ls
    if [ $# -eq 0 ]; then
        ls
    else
        # Check if first argument is a directory
        if [ -d "$1" ]; then
            ls "$1"
        else
            # Treat as a command with arguments
            "$@"
        fi
    fi

    # Sleep and clear
    sleep "$sleep_rate"
    clear
}


#CLIP function that copies content of file to clipboard
clip() {
  if [ -f "$1" ]; then
    cat "$1" | xclip -selection clipboard
    echo "successfully copied file: '$1' to clipboard"
  else
    echo "File not found: '$1'"
  fi
}

#ros sourcer, typically used after build.
# Source ros workspace
./source() {
  # setup source directories based on ROS1, ROS2
  if [[ "$IS_ROS1" == false ]]; then
    setup_dir="install"
  else
    setup_dir="devel"
  fi

  local setup_file="./$setup_dir/setup.bash"

  if [ "$1" = "-ws" ]; then
    setup_file="${ROS_WS}/$setup_dir/setup.bash"
  else
    setup_file="./$setup_dir/setup.bash"
  fi  

  if [ -f "$setup_file" ]; then
    echo "Sourcing $setup_file ..."
    source "$setup_file"
    echo "Sourced workspace: $ROS_WS"
  else
    echo "No $setup_dir/setup.bash found in: $(pwd)"
  fi
}

# Source venv for ros
./rosenv() {
    local venv_file="$HOME/rosenv/bin/activate"
    if [[ "$1" == "-d" && -n "$VIRTUAL_ENV" ]]; then
      deactivate
      return
    fi

    if [[ -f "$venv_file" && -z "$VIRTUAL_ENV" ]]; then
      source "$venv_file"
    elif [[ ! -f "$venv_file" ]]; then
      echo "No virtual environment found at $venv_file"
    fi
}

# Shortcut function for colcon packages with subdirectory support
./cd() {
    if [ $# -eq 0 ]; then
        echo "Usage: ./cd <package_path>"
        return 1
    fi

    local package="${1%%/*}"      # first component
    local remainder="${1#*/}"     # rest after first /

    # Go to package root
    local package_dir="${ROS_WS}/src/$package"
    if [ ! -d "$package_dir" ]; then
        echo "Package not found: $package"
        return 1
    fi
    cd "$package_dir" || return 1

    # Go to subdirectory if specified
    if [ "$remainder" != "$package" ]; then
        cd "$remainder" || return 1
    fi
}

_ccd_completion() {
    local curr_word="${COMP_WORDS[COMP_CWORD]}"
    local package="${curr_word%%/*}"
    local remainder="${curr_word#*/}"
    local package_dir="${ROS_WS}/src/$package"

    if [ -d "$package_dir" ]; then 
        local dirs=( $(find "$package_dir" -maxdepth 1 -type d -printf "%f\n") ) 
        if [ "$remainder" != "$curr_word" ]; then
            # Completing inside a package
            COMPREPLY=( $(compgen -W "${dirs[*]}" -- "$remainder") )
            COMPREPLY=( "${COMPREPLY[@]/#/$package/}" )

            # If only 1 match, append slash automatically
            if [ ${#COMPREPLY[@]} -eq 1 ] && [ -d "${package_dir}/${COMPREPLY[0]#*/}" ]; then
                COMPREPLY[0]="${COMPREPLY[0]}/"
            fi
        else
            # Completing the package itself
            COMPREPLY=( $(compgen -W "${dirs[*]}" -- "$curr_word") )
            if [ ${#COMPREPLY[@]} -eq 1 ] && [ -d "${package_dir}/${COMPREPLY[0]}" ]; then
                COMPREPLY[0]="${COMPREPLY[0]}/"
            fi
        fi
    else
        # Top-level package completion
        local packages=( $(ls -d "${ROS_WS}/src"/*/ 2>/dev/null | xargs -n1 basename) )
        COMPREPLY=( $(compgen -W "${packages[*]}" -- "$curr_word") )
        if [ ${#COMPREPLY[@]} -eq 1 ] && [ -d "${ROS_WS}/src/${COMPREPLY[0]}" ]; then
            COMPREPLY[0]="${COMPREPLY[0]}/"
        fi
    fi

    # Tell Bash not to append space automatically
    compopt -o nospace
}

# Attach completion with -o nospace to avoid auto space
complete -o nospace -F _ccd_completion ./cd



### aliases

# show alias for explorer popup
if [ "$IS_WSL" = true ]; then
    alias show="explorer.exe"
else
    alias show="nautilus"
fi

if [[ "$IS_ROS1" == false ]]; then
  alias cb="colcon build --symlink-install"
  alias cbp="colcon build --symlink-install --packages-select"
else
  alias cb="catkin_make"
  alias cbp="catkin_make --pkg"
fi

echo -e "custom alias for Ariuna was loaded.\n"

### ros2 setup
#ROS_DISTRO="foxy" # jazzy, noetic
if [ -z "${ROS_DISTRO}" ]; then
  export ROS_DISTRO="jazzy" # jazzy, noetic
  echo "ROS_DISTRO set to '${ROS_DISTRO}'"
fi
if [ -z "${ROS_WS}" ]; then
  export ROS_WS="$HOME/ros2_ws" # jazzy, noetic
  echo "ROS_WS set to '${ROS_WS}'"
fi

source /opt/ros/${ROS_DISTRO}/setup.bash
source ${ROS_WS}/$setup_dir/setup.bash

if [[ "$IS_ROS1" == false ]]; then
  source /usr/share/colcon_argcomplete/hook/colcon-argcomplete.bash
  source /usr/share/colcon_cd/function/colcon_cd.sh
  source /usr/share/colcon_cd/function/colcon_cd-argcomplete.bash
fi

echo -e "custom bash setup for Ariuna was loaded.\n"
sleep 0.3
clear
cd ${ROS_WS}
